export const datas = {
  "bool_always_false.mls":
    "type bool =\n  | False\n  | True\n\nsynth bool -> bool satisfying\n\n[True] -> False,\n[False] -> False\n",
  "bool_always_true.mls":
    "type bool =\n  | False\n  | True\n\nsynth bool -> bool satisfying\n\n[True] -> True,\n[False] -> True\n",
  "bool_band.mls":
    "type bool =                                   \n  | False                                     \n  | True                                      \n\nsynth bool -> bool -> bool satisfying\n\n[True,True] -> True,\n[True,False] -> False,\n[False,True] -> False,\n(*[False,False] -> False*)\n",
  "bool_bor.mls":
    "type bool =                                   \n  | False                                     \n  | True                                      \n\nsynth bool -> bool -> bool satisfying\n\n(*[True,True] -> True,*)\n[True,False] -> True,\n[False,True] -> True,\n[False,False] -> False\n",
  "bool_impl.mls":
    "type bool =                                   \n  | False                                     \n  | True                                      \n\nsynth bool -> bool -> bool satisfying\n\n[True,True] -> True,\n[True,False] -> False,\n(*[False,True] -> True,*)\n[False,False] -> True\n",
  "bool_neg.mls":
    "type bool =                                   \n  | False                                     \n  | True                                      \n\nsynth bool -> bool satisfying\n\n[True] -> False,\n[False] -> True\n",
  "bool_xor.mls":
    "type bool =                                   \n  | False                                     \n  | True                                      \n\nsynth bool -> bool -> bool satisfying\n\n[True,True] -> False,\n[True,False] -> True,\n[False,True] -> True,\n[False,False] -> False\n",
  "list_append.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\nsynth list -> list -> list satisfying\n\n[Nil,Nil] -> Nil,\n[Cons(1,Cons(0,Nil)),Nil] -> Cons(1,Cons(0,Nil)),\n[Cons(0,Nil),Cons(0,Nil)] -> Cons(0,Cons(0,Nil)),\n[Cons(1,Cons(0,Nil)),Cons(0,Nil)] -> Cons(1,Cons(0,Cons(0,Nil))),\n",
  "list_compress.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\ntype cmp =\n  | LT\n  | EQ\n  | GT\n\nlet compare =\n  fix (compare : nat -> nat -> cmp) =\n    fun (x1 : nat) ->\n      fun (x2 : nat) ->\n        match x1 with\n        | O -> (match x2 with\n                | O -> EQ\n                | S _ -> LT)\n        | S x1 -> (match x2 with\n                | O -> GT\n                | S x2 -> compare x1 x2)\n;;\n\nsynth list -> list satisfying\n\n[Nil] -> Nil,\n[Cons(0,Nil)] -> Cons(0,Nil),\n[Cons(1,Nil)] -> Cons(1,Nil),\n[Cons(0,Cons(0,Nil))] -> Cons(0,Nil),\n[Cons(1,Cons(1,Nil))] -> Cons(1,Nil),\n[Cons(2,Cons(0,Nil))] -> Cons(2,Cons(0,Nil)),\n[Cons(1,Cons(0,Cons(0,Nil)))] -> Cons(1,Cons(0,Nil)),\n[Cons(0,Cons(1,Cons(1,Nil)))] -> Cons(0,Cons(1,Nil)),\n[Cons(2,Cons(1,Cons(0,Cons(0,Nil))))] -> Cons(2,Cons(1,Cons(0,Nil))),\n[Cons(2,Cons(2,Cons(1,Cons(0,Cons(0,Nil)))))] -> Cons(2,Cons(1,Cons(0,Nil))),\n[Cons(2,Cons(2,Cons(0,Nil)))] -> Cons(2,Cons(0,Nil)),\n[Cons(2,Cons(2,Cons(2,Cons(0,Nil))))] -> Cons(2,Cons(0,Nil)),\n[Cons(1,Cons(2,Cons(2,Cons(2,Cons(0,Nil)))))] -> Cons(1,Cons(2,Cons(0,Nil))),",
  "list_concat.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\ntype llist =\n  | LNil\n  | LCons of list * llist\n\nlet append =\n  fix (append : list -> list -> list) =\n    fun (l1 : list) ->\n      fun (l2 : list) ->\n        match l1 with\n        | Nil -> l2\n        | Cons (h,t) -> Cons(h,append t l2)\n;;\n\nsynth llist -> list satisfying\n\n[LNil] -> Nil,\n[LCons(Cons(0,Nil),LNil)] -> Cons(0,Nil),\n[LCons(Cons(0,Nil),LCons(Cons(0,Nil),LNil))] -> Cons(0,Cons(0,Nil)),\n[LCons(Cons(1,Nil),LNil)] -> Cons(1,Nil),\n[LCons(Cons(1,Nil),LCons(Cons(1,Nil),LNil))] -> Cons(1,Cons(1,Nil)),\n",
  "list_drop.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\nsynth list -> nat -> list satisfying\n\n[Nil,0] -> Nil,\n[Cons(1,Nil),0] -> Cons(1,Nil),\n[Cons(1,Nil),1] -> Nil,\n[Cons(1,Cons(0,Nil)),1] -> Cons(0,Nil),\n[Cons(0,Cons(1,Nil)),2] -> Nil,",
  "list_even_parity.mls":
    "type bool =\n  | True\n  | False\n\ntype list =\n  | Nil\n  | Cons of bool * list\n\nsynth list -> bool satisfying\n\n[Nil] -> True,\n[Cons(False,Nil)] -> True,\n[Cons(True,Nil)] -> False,\n[Cons(False,Cons(False,Nil))] -> True,\n[Cons(False,Cons(True,Nil))] -> False,\n[Cons(True,Cons(False,Nil))] -> False,\n[Cons(True,Cons(True,Nil))] -> True,",
  "list_filter.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\ntype bool =\n  | True\n  | False\n\nlet is_even =\n  fix (is_even : nat -> bool) =\n    fun (x1 : nat) ->\n      match x1 with\n      | O -> True\n      | S x1p ->\n        (match x1p with\n         | O -> False\n         | S x1pp -> is_even x1pp)\n;;\n\nlet is_nonzero =\n  fun (x1 : nat) ->\n    match x1 with\n    | O -> False\n    | S _ -> True\n;;\n\nsynth (nat -> bool) -> list -> list satisfying\n\n[is_even,Nil] -> Nil,\n[is_even,Cons(2,Nil)] -> Cons(2,Nil),\n[is_even,Cons(0,Cons(0,Nil))] -> Cons(0,Cons(0,Nil)),\n[is_even,Cons(1,Cons(0,Cons(1,Nil)))] -> Cons(0,Nil),\n[is_nonzero,Cons(0,Nil)] -> Nil,\n",
  "list_fold.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\ntype bool =\n  | True\n  | False\n\nlet sum =\n  fix (sum : nat -> nat -> nat) =\n    fun (n1 : nat) ->\n      fun (n2 : nat) ->\n        match n1 with\n        | O -> n2\n        | S n1p -> S (sum n1p n2)\n;;\n\nlet is_odd =\n  fix (is_odd : nat -> bool) =\n    fun (x1 : nat) ->\n      match x1 with\n      | O -> False\n      | S x1p ->\n        (match x1p with\n         | O -> True\n         | S x1pp -> is_odd x1pp)\n;;\n\nlet count_odd =\n  fun (n1:nat) ->\n    fun (n2:nat) ->\n      match is_odd n2 with\n      | True -> S n1\n      | False -> n1\n;;\n\nsynth (nat -> nat -> nat) -> nat -> list -> nat satisfying\n\n[sum,0,Nil] -> 0,\n[sum,0,Cons(2,Cons(1,Nil))] -> 3,\n[sum,0,Cons(3,Cons(2,Cons(1,Nil)))] -> 6,\n",
  "list_hd.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\nsynth list -> nat satisfying\n\n[Nil] -> 0,\n[Cons(1,Nil)] -> 1,\n[Cons(2,Cons(1,Nil))] -> 2\n",
  "list_inc.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\nlet map =\n  fix (map : list -> (nat -> nat) -> list) =\n    fun (l1 : list) ->\n      fun (f : nat -> nat) ->\n        match l1 with\n        | Nil -> Nil\n        | Cons (h,t) -> Cons (f h, map t f)\n;;\n\nsynth list -> list satisfying\n\n[Nil] -> Nil,\n[Cons(1,Cons(2,Nil))] -> Cons(2,Cons(3,Nil)),\n[Cons(0,Cons(0,Nil))] -> Cons(1,Cons(1,Nil)),\n[Cons(3,Cons(4,Cons(5,Nil)))] -> Cons(4,Cons(5,Cons(6,Nil))),\n",
  "list_last.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\ntype natopt =\n  | None\n  | Some of nat\n\nsynth list -> natopt satisfying\n\n[Nil] -> None,\n[Cons(1,Nil)] -> Some (1),\n[Cons(2,Nil)] -> Some (2),\n[Cons(2,Cons(1,Nil))] -> Some (1),\n[Cons(1,Cons(2,Nil))] -> Some (2),\n[Cons(3,Cons(2,Cons(1,Nil)))] -> Some (1),\n",
  "list_length.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\nsynth list -> nat satisfying\n\n[Nil] -> 0,\n[Cons(0,Nil)] -> 1,\n[Cons(0,Cons(0,Nil))] -> 2,\n",
  "list_map.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\nlet zero =\n  fun (n:nat) -> O\n;;\n\nlet inc =\n  fun (n:nat) -> S (n)\n;;\n\n\nsynth (nat -> nat) -> list -> list satisfying\n\n[inc,Nil] -> Nil,\n[inc,Cons(0,Nil)] -> Cons(1,Nil),\n[inc,Cons(0,Cons(0,Nil))] -> Cons(1,Cons(1,Nil)),\n[zero,Cons(0,Cons(0,Nil))] -> Cons(0,Cons(0,Nil)),\n",
  "list_nth.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\nsynth list -> nat -> nat satisfying\n\n[Nil,1] -> 0,\n[Cons(2,Nil),1] -> 0,\n[Cons(1,Cons(2,Nil)),0] -> 1,\n[Cons(1,Cons(2,Nil)),1] -> 2,\n[Cons(2,Cons(1,Nil)),0] -> 2,\n[Cons(3,Cons(2,Cons(1,Nil))),0] -> 3,\n[Cons(4,Cons(3,Cons(2,Cons(1,Nil)))),1] -> 3,\n",
  "list_pairwise_swap.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\nsynth list -> list satisfying\n\n[Nil] -> Nil,\n[Cons(1,Nil)] -> Nil,\n[Cons(1,Cons(0,Nil))] -> Cons(0,Cons(1,Nil)),\n[Cons(1,Cons(0,Cons(1,Nil)))] -> Nil,\n[Cons(0,Cons(1,Cons(0,Cons(1,Nil))))] -> Cons(1,Cons(0,Cons(1,Cons(0,Nil)))),\n",
  "list_rev_append.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\nlet append =\n  fix (append : list -> list -> list) =\n    fun (l1 : list) ->\n      fun (l2 : list) ->\n        match l1 with\n        | Nil -> l2\n        | Cons (h,t) -> Cons(h,append t l2)\n;;\n\nsynth list -> list satisfying\n\n[Nil] -> Nil,\n[Cons(0,Nil)] -> Cons(0,Nil),\n[Cons(0,Cons(0,Cons(1,Nil)))] -> Cons(1,Cons(0,Cons(0,Nil))),\n\n(* FTA construction is unexpectedly slow *)\n",
  "list_rev_fold.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\nlet snoc =\n  fix (snoc : list -> nat -> list) =\n    fun (l1 : list) ->\n      fun (n : nat) ->\n        match l1 with\n        | Nil -> Cons (n, Nil)\n        | Cons (h,t) -> Cons(h,snoc t n)\n;;\n\nlet fold =\n  fix (fold : (list -> nat -> list) -> list -> list -> list) =\n    fun (f:(list -> nat -> list)) ->\n      fun (init:list) ->\n        fun (l:list) ->\n          match l with\n          | Nil -> init\n          | Cons (h,t) -> f (fold f init t) h\n;;\n\nsynth list -> list satisfying\n\n[Nil] -> Nil,\n[Cons(0,Cons(1,Nil))] -> Cons(1,Cons(0,Nil)),\n",
  "list_rev_snoc.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\nlet snoc =\n  fix (snoc : list -> nat -> list) =\n    fun (l1 : list) ->\n      fun (n : nat) ->\n        match l1 with\n        | Nil -> Cons (n, Nil)\n        | Cons (h,t) -> Cons(h,snoc t n)\n;;\n\nsynth list -> list satisfying\n\n[Nil] -> Nil,\n[Cons(0,Nil)] -> Cons(0,Nil),\n[Cons(1,Nil)] -> Cons(1,Nil),\n[Cons(0,Cons(1,Nil))] -> Cons(1,Cons(0,Nil)),\n[Cons(0,Cons(1,Cons(2,Nil)))] -> Cons(2,Cons(1,Cons(0,Nil))),\n",
  "list_rev_tailcall.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\nsynth list -> list -> list satisfying\n\n[Nil,Nil] -> Nil,\n[Cons(0,Nil),Nil] -> Cons(0,Nil),\n[Cons(0,Cons(1,Nil)),Nil] -> Cons(1,Cons(0,Nil)),\n",
  "list_snoc.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\nsynth list -> nat -> list satisfying\n\n[Nil,0] -> Cons(0,Nil),\n[Nil,1] -> Cons(1,Nil),\n[Cons(2,Cons(1,Cons(0,Nil))),1] -> Cons(2,Cons(1,Cons(0,Cons(1,Nil)))),\n",
  "list_sort_sorted_insert.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\ntype cmp =\n  | LT\n  | EQ\n  | GT\n\nlet compare =\n  fix (compare : nat -> nat -> cmp) =\n    fun (x1 : nat) ->\n      fun (x2 : nat) ->\n        match x1 with\n        | O -> (match x2 with\n                | O -> EQ\n                | S _ -> LT)\n        | S x1 -> (match x2 with\n                | O -> GT\n                | S x2 -> compare x1 x2)\n;;\n\nlet insert =\n  fix (insert : list -> nat -> list) =\n    fun (l1 : list) ->\n      fun (n : nat) ->\n        match l1 with\n        | Nil -> Cons (n, Nil)\n        | Cons (h,t) -> (match compare n h with\n                | LT -> Cons (n, l1)\n                | EQ -> l1\n                | GT -> Cons (h, insert t n))\n;;\n\nsynth list -> list satisfying\n\n[Nil] -> Nil,\n[Cons(1,Cons(1,Nil))] -> Cons(1,Nil),\n[Cons(0,Cons(1,Cons(1,Nil)))] -> Cons(0,Cons(1,Nil)),",
  "list_sorted_insert.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\ntype cmp =\n  | LT\n  | EQ\n  | GT\n\nlet compare =\n  fix (compare : nat -> nat -> cmp) =\n    fun (x1 : nat) ->\n      fun (x2 : nat) ->\n        match x1 with\n        | O -> (match x2 with\n                | O -> EQ\n                | S _ -> LT)\n        | S x1 -> (match x2 with\n                | O -> GT\n                | S x2 -> compare x1 x2)\n;;\n\nsynth list -> nat -> list satisfying\n\n[Nil,0] -> Cons(0,Nil),\n[Cons(1,Nil),1] -> Cons(1,Nil),\n[Cons(1,Nil),2] -> Cons(1,Cons(2,Nil)),\n[Cons(2,Nil),0] -> Cons(0,Cons(2,Nil)),\n[Cons(2,Nil),1] -> Cons(1,Cons(2,Nil)),\n[Cons(0,Cons(1,Nil)),0] -> Cons(0,Cons(1,Nil)),\n[Cons(0,Cons(1,Nil)),2] -> Cons(0,Cons(1,Cons(2,Nil))),\n",
  "list_stutter.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\nsynth list -> list satisfying\n\n[Nil] -> Nil,\n[Cons(1,Cons(0,Nil))] -> Cons(1,Cons(1,Cons(0,Cons(0,Nil)))),\n\n(* should be 5, whyyyyy *)",
  "list_sum.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\nlet fold =\n  fix (fold : (nat -> nat -> nat) -> nat -> list -> nat) =\n    fun (f:nat -> nat -> nat) ->\n      fun (acc:nat) ->\n        fun (l1:list) ->\n          match l1 with\n          | Nil -> acc\n          | Cons (h,t) -> fold f (f acc h) t\n;;\n\nlet add =\n  fix (add : nat -> nat -> nat) =\n    fun (n1 : nat) ->\n      fun (n2 : nat) ->\n        match n1 with\n        | O -> n2\n        | S n1p -> S (add n1p n2)\n;;\n\nsynth list -> nat satisfying\n\n[Nil] -> 0,\n[Cons(2,Cons(1,Nil))] -> 3,\n\n(* needs extra examples *)\n",
  "list_take.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\nsynth nat -> list -> list satisfying\n\n[0,Nil] -> Nil,\n[0,Cons(0,Cons(1,Nil))] -> Nil,\n[1,Cons(1,Nil)] -> Cons(1,Nil),\n[1,Cons(0,Cons(1,Nil))] -> Cons(0,Nil),\n[2,Cons(1,Cons(0,Cons(1,Nil)))] -> Cons(1,Cons(0,Nil)),\n",
  "list_tl.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\nsynth list -> list satisfying\n\n[Nil] -> Nil,\n[Cons(0,Cons(0,Nil))] -> Cons(0,Nil),\n[Cons(0,Cons(1,Nil))] -> Cons(1,Nil),\n",
  "nat_add.mls":
    "type nat =\n  | O\n  | S of nat\n\nsynth nat -> nat -> nat satisfying\n\n[0,0] -> 0,\n[0,1] -> 1,\n[1,0] -> 1,\n[1,1] -> 2,\n[0,2] -> 2,\n[2,0] -> 2,\n[1,2] -> 3,\n[2,1] -> 3,\n",
  "nat_iseven.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype bool =\n  | True\n  | False\nsynth nat -> bool satisfying\n\n[0] -> True,\n[2] -> True,\n[3] -> False\n",
  "nat_max.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype bool =\n  | True\n  | False\n\ntype cmp =\n  | LT\n  | EQ\n  | GT\n\nlet compare =\n  fix (compare : nat -> nat -> cmp) =\n    fun (x1 : nat) ->\n      fun (x2 : nat) ->\n        match x1 with\n        | O -> (match x2 with\n                | O -> EQ\n                | S _ -> LT)\n        | S x1 -> (match x2 with\n                | O -> GT\n                | S x2 -> compare x1 x2)\n;;\n\nsynth nat -> nat -> nat satisfying\n\n[0,0] -> 0,\n[0,1] -> 1,\n[0,2] -> 2,\n[1,0] -> 1,\n[1,1] -> 1,\n[1,2] -> 2,\n[2,0] -> 2,\n[2,1] -> 2,\n[2,2] -> 2\n",
  "nat_pred.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype bool =\n  | True\n  | False\n\nsynth nat -> nat satisfying\n\n[0] -> 0,\n[2] -> 1\n",
  "tree_binsert.mls":
    "type cmp =\n  | CEq\n  | CGt\n  | CLt\n\ntype nat =\n  | O\n  | S of nat\n\ntype tree =\n  | Leaf\n  | Node of tree * nat * tree\n\nlet comp_nat =\n  fix (comp_nat : nat -> nat -> cmp) =\n    fun (x1 : nat) ->\n      fun (x2 : nat) ->\n        match x1 with\n        | O -> (match x2 with\n                | O -> CEq\n                | S _ -> CLt)\n        | S x1 -> (match x2 with\n                | O -> CGt\n                | S x2 -> comp_nat x1 x2)\n;;\n\nsynth tree -> nat -> tree satisfying\n\n[Leaf,0] -> Node (Leaf, 0, Leaf),\n[Leaf,1] -> Node (Leaf, 1, Leaf),\n[Leaf,2] -> Node (Leaf, 2, Leaf),\n[Node (Leaf, 1, Leaf),0] -> Node (Node (Leaf, 0, Leaf), 1, Leaf),\n[Node (Leaf, 1, Leaf),1] -> Node (Leaf, 1, Leaf),\n[Node (Leaf, 1, Leaf),2] -> Node (Leaf, 1, Node (Leaf, 2, Leaf)),\n[Node (Leaf, 0, Leaf),0] -> Node (Leaf, 0, Leaf),\n[Node (Leaf, 0, Leaf),1] -> Node (Leaf, 0, Node (Leaf, 1, Leaf)),\n[Node (Leaf, 0, Leaf),2] -> Node (Leaf, 0, Node (Leaf, 2, Leaf)),\n[Node (Leaf, 2, Leaf),0] -> Node (Node (Leaf, 0, Leaf), 2, Leaf),\n[Node (Leaf, 2, Leaf),1] -> Node (Node (Leaf, 1, Leaf), 2, Leaf),\n[Node (Leaf, 2, Leaf),2] -> Node (Leaf, 2, Leaf),\n[Node (Node (Leaf, 0, Leaf), 1, Leaf),0] -> Node (Node (Leaf, 0, Leaf), 1, Leaf),\n[Node (Node (Leaf, 0, Leaf), 1, Leaf),1] -> Node (Node (Leaf, 0, Leaf), 1, Leaf),\n[Node (Node (Leaf, 0, Leaf), 1, Leaf),2] -> Node (Node (Leaf, 0, Leaf), 1, Node (Leaf, 2, Leaf)),\n[Node (Leaf, 0, Node (Leaf, 1, Leaf)),2] -> Node (Leaf, 0, Node (Leaf, 1, Node (Leaf, 2, Leaf))),\n[Node (Node (Leaf, 1, Leaf), 2, Leaf),0] -> Node (Node (Node(Leaf, 0, Leaf), 1, Leaf), 2, Leaf),\n[Node (Leaf, 1, Node (Leaf, 2, Leaf)),0] -> Node (Node (Leaf, 0, Leaf), 1, Node (Leaf, 2, Leaf)),\n[Node (Leaf, 1, Node (Leaf, 2, Leaf)),1] -> Node (Leaf, 1, Node (Leaf, 2, Leaf)),\n[Node (Node (Leaf, 1, Leaf), 2, Leaf),0] -> Node (Node (Node(Leaf, 0, Leaf), 1, Leaf), 2, Leaf)\n",
  "tree_collect_leaves.mls":
    "type bool =\n  | True\n  | False\n\ntype tree =\n  | Leaf\n  | Node of tree * bool * tree\n\ntype list =\n  | Nil\n  | Cons of bool * list\n\nlet append =\n  fix (append : list -> list -> list) =\n    fun (l1 : list) ->\n      fun (l2 : list) ->\n        match l1 with\n        | Nil -> l2\n        | Cons (h,t) -> Cons(h,append t l2)\n;;\n\nsynth tree -> list satisfying\n\n[Leaf] -> Nil,\n[Node (Node (Leaf, True, Leaf), False, Leaf)] -> Cons(True, Cons(False, Nil)),\n[Node (Leaf, False, Node (Leaf, True, Leaf))] -> Cons(False, Cons(True, Nil)),\n",
  "tree_count_leaves.mls":
    "type bool =\n  | True\n  | False\n\ntype tree =\n  | Leaf\n  | Node of tree * bool * tree\n\ntype nat =\n  | O\n  | S of nat\n\nlet sum =\n  fix (sum : nat -> nat -> nat) =\n    fun (n1 : nat) ->\n      fun (n2 : nat) ->\n        match n1 with\n        | O -> n2\n        | S n1p -> S (sum n1p n2)\n;;\n\nsynth tree -> nat satisfying\n\n[Leaf] -> 1,\n[Node (Node (Leaf, True, Leaf), True, Leaf)] -> 3,\n[Node (Node (Leaf, True, Leaf), True, Node (Leaf, True, Leaf))] -> 4,\n",
  "tree_count_nodes.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype tree =\n  | Leaf\n  | Node of tree * nat * tree\n\nlet sum =\n  fix (sum : nat -> nat -> nat) =\n    fun (n1 : nat) ->\n      fun (n2 : nat) ->\n        match n1 with\n        | O -> n2\n        | S n1p -> S (sum n1p n2)\n;;\n\nsynth tree -> nat satisfying\n\n[Leaf] -> 0,\n[Node (Leaf, 0, Leaf)] -> 1,\n[Node (Node (Leaf, 0, Leaf), 0, Leaf)] -> 2,\n[Node (Leaf, 0, Node (Leaf, 0, Leaf))] -> 2,\n[Node (Node (Leaf, 0, Node (Leaf, 0, Leaf)), 0, Leaf)] -> 3,\n[Node (Leaf, 0, Node (Leaf, 0, Node (Leaf, 0, Leaf)))] -> 3,\n",
  "tree_inorder.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\ntype tree =\n  | Leaf\n  | Node of tree * nat * tree\n\nlet append =\n  fix (append : list -> list -> list) =\n    fun (l1 : list) ->\n      fun (l2 : list) ->\n        match l1 with\n        | Nil -> l2\n        | Cons (h,t) -> Cons(h,append t l2)\n;;\n\nsynth tree -> list satisfying\n\n[Leaf] -> Nil,\n[Node (Leaf, 1, Leaf)] -> Cons(1, Nil),\n[Node (Node (Leaf, 1, Leaf), 2, Leaf)] -> Cons(1, Cons(2, Nil)),\n[Node (Leaf, 1, Node (Leaf, 2, Leaf))] -> Cons(1, Cons(2, Nil)),\n\n(* this slow *)",
  "tree_map.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\ntype tree =\n  | Leaf\n  | Node of tree * nat * tree\n\nlet div2 =\n  fix (div2 : nat -> nat) =\n    fun (n : nat) ->\n      match n with\n      | O -> O\n      | S np ->\n        (match np with\n         | O -> O\n         | S npp -> S (div2 npp))\n;;\n\nlet inc =\n  fun (n : nat) ->\n    S n\n;;\n\nsynth (nat -> nat) -> tree -> tree satisfying\n\n[div2,Leaf] -> Leaf,\n[div2,Node (Node (Leaf, 2, Leaf), 2, Leaf)] -> Node (Node (Leaf, 1, Leaf), 1, Leaf),\n[div2,Node (Leaf, 1, Node (Leaf, 2, Leaf))] -> Node (Leaf, 0, Node (Leaf, 1, Leaf)),\n[inc,Node (Leaf, 0, Leaf)] -> Node (Leaf, 1, Leaf),\n",
  "tree_nodes_at_level.mls":
    "type bool =\n  | True\n  | False\n\ntype tree =\n  | Leaf\n  | Node of tree * bool * tree\n\ntype nat =\n  | O\n  | S of nat\n\nlet sum =\n  fix (sum : nat -> nat -> nat) =\n    fun (n1 : nat) ->\n      fun (n2 : nat) ->\n        match n1 with\n        | O -> n2\n        | S n1p -> S (sum n1p n2)\n;;\n\nsynth tree -> nat -> nat satisfying\n\n[Leaf,0] -> 0,\n[Leaf,1] -> 0,\n[Leaf,2] -> 0,\n[Leaf,3] -> 0,\n[Node (Leaf, True, Leaf),0] -> 1,\n[Node (Leaf, True, Leaf),1] -> 0,\n[Node (Leaf, True, Leaf),2] -> 0,\n[Node (Leaf, True, Leaf),3] -> 0,\n[Node (Node (Leaf, True, Leaf), True, Leaf),0] -> 1,\n[Node (Node (Leaf, True, Leaf), True, Leaf),1] -> 1,\n[Node (Node (Leaf, True, Leaf), True, Leaf),2] -> 0,\n[Node (Node (Leaf, True, Leaf), True, Leaf),3] -> 0,\n[Node (Leaf, True, Node (Leaf, True, Leaf)),0] -> 1,\n[Node (Leaf, True, Node (Leaf, True, Leaf)),1] -> 1,\n[Node (Leaf, True, Node (Leaf, True, Leaf)),2] -> 0,\n[Node (Leaf, True, Node (Leaf, True, Leaf)),3] -> 0,\n[Node (Node (Leaf, True, Leaf), True, Node (Leaf, True, Leaf)),0] -> 1,\n[Node (Node (Leaf, True, Leaf), True, Node (Leaf, True, Leaf)),1] -> 2,\n[Node (Node (Leaf, True, Leaf), True, Node (Leaf, True, Leaf)),2] -> 0,\n[Node (Node (Leaf, True, Leaf), True, Node (Leaf, True, Leaf)),3] -> 0,\n[Node (Node (Node (Leaf, True, Leaf), True, Node (Leaf, True, Leaf)), True, Leaf),0] -> 1,\n[Node (Node (Node (Leaf, True, Leaf), True, Node (Leaf, True, Leaf)), True, Leaf),1] -> 1,\n[Node (Node (Node (Leaf, True, Leaf), True, Node (Leaf, True, Leaf)), True, Leaf),2] -> 2,\n[Node (Node (Node (Leaf, True, Leaf), True, Node (Leaf, True, Leaf)), True, Leaf),3] -> 0,",
  "tree_postorder.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\ntype tree =\n  | Leaf\n  | Node of tree * nat * tree\n\nlet append =\n  fix (append : list -> list -> list) =\n    fun (l1 : list) ->\n      fun (l2 : list) ->\n        match l1 with\n        | Nil -> l2\n        | Cons (h,t) -> Cons(h,append t l2)\n;;\n\nsynth tree -> list satisfying\n\n[Leaf] -> Nil,\n[Node (Leaf, 1, Leaf)] -> Cons(1, Nil),\n[Node (Leaf, 2, Leaf)] -> Cons(2, Nil),\n[Node (Node (Leaf, 1, Leaf), 2, Leaf)] -> Cons(1, Cons(2, Nil)),\n[Node (Leaf, 1, Node (Leaf, 2, Leaf))] -> Cons(2, Cons(1, Nil)),\n[Node (Node (Leaf, 1, Leaf), 0, Node (Leaf, 2, Leaf))] -> Cons (1, Cons(2, Cons(0, Nil))),\n[Node (Node (Leaf, 2, Leaf), 0, Node (Leaf, 1, Leaf))] -> Cons (2, Cons(1, Cons(0, Nil))),\n[Node (Node (Node (Leaf, 2, Leaf), 0, Node (Leaf, 1, Leaf)), 0, Leaf)] -> Cons (2, Cons(1, Cons(0, Cons(0, Nil)))),\n[Node (Leaf, 2, Node (Node (Leaf, 2, Leaf), 0, Node (Leaf, 1, Leaf)))] -> Cons (2, Cons(1, Cons(0, Cons(2, Nil)))),\n\n(* this slow *)\n",
  "tree_preorder.mls":
    "type nat =\n  | O\n  | S of nat\n\ntype list =\n  | Nil\n  | Cons of nat * list\n\ntype tree =\n  | Leaf\n  | Node of tree * nat * tree\n\nlet append =\n  fix (append : list -> list -> list) =\n    fun (l1 : list) ->\n      fun (l2 : list) ->\n        match l1 with\n        | Nil -> l2\n        | Cons (h,t) -> Cons(h,append t l2)\n;;\n\nsynth tree -> list satisfying\n\n[Leaf] -> Nil,\n[Node (Node (Leaf, 1, Leaf), 2, Leaf)] -> Cons(2, Cons(1, Nil)),\n[Node (Leaf, 1, Node (Leaf, 2, Leaf))] -> Cons(1, Cons(2, Nil)),\n\n",
};
